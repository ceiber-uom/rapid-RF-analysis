

function response = fitDoubleExponential(wave, varargin)
% estimate = estimatePeriodicComponent( wave, [time], [expoData], <args> )
%                                     ( wave, time, tInfo, <args> )
% Decomposes the input wave into a pair of response functions of the form 
%     k * (exp(-a*t) - exp(-b*t)), one for the DC component and one for the
%     AC component. 
% 
% tInfo may be generated by 
%    tInfo = Tools.estimateWaveLag(wave,time,expoData);


named = @(n) strncmpi(varargin,n,length(n));
do_PLOT = any(named('-plot')); 

if nargin == 0 || nargin > 1e3, do_PLOT = true; 
    
    disp('Running demonstration (PCA 1):')
    Tools.loadPhysiology('8.6.1 #18','-pca','-nK',6);
    wave = score(:,1); %#ok<NODEF>
    
    tInfo = Tools.estimateWaveLag(wave,'-plot'); 
    
    % Remove variables that non-test-case use doesn't have access to
    clear coeff coe_scale filename hekaData nPasses 
    clear passes resting score stim_bar

elseif nargin < 3
     expoData = evalin('caller','expoData'); % Needed to compute tInfo
     time = evalin('caller','time');
     tInfo = Tools.estimateWaveLag(wave,time,expoData);
else 
     tInfo = varargin{2};
     time = varargin{1};
     if isfield(tInfo,'ExpoVersion'), % passed in as (wave,time,expoData)
          tInfo = Tools.estimateWaveLag(wave,time,tInfo);
     end
end

nS = tInfo.nStimuli; 
fs = 1./ mean(diff(time));
roi = (tInfo.index : size(wave,1));

C = lines(7); G = @(v) [v v v]/10; 

%% Set up filters to extract AC and DC halves of response
persistent filters
if isempty(filters) || filters.TF ~= nS
    filters.TF = nS; 
    
    if nS > 1, Fd = fdesign.lowpass('N,F3dB',6,nS*0.7,fs);
    else       Fd = fdesign.lowpass('N,F3dB',6,nS*1.5,fs);
    end
    Hd = design(Fd, 'butter'); 
    set(Hd, 'Arithmetic', 'double');

    filters.LP_SOS = Hd.sosMatrix;
    filters.LP_G = Hd.ScaleValues;
    
    Fd = fdesign.lowpass('N,F3dB',6,nS*1.8,fs);
    Hd = design(Fd, 'butter'); 
    set(Hd, 'Arithmetic', 'double');
        
    filters.HP_SOS = Hd.sosMatrix;
    filters.HP_G = Hd.ScaleValues;
    
    clear Fd Hd    
end

wave_DC = filtfilt(filters.LP_SOS,filters.LP_G, wave);

%% 

% We're going to fit a double-exponential pulse to this wave for the
% non-stationary baseline. 

% E(t) = E0 k (exp(-a.t) - exp(-b.t)) h(t) ~ amplitude, charactaristics
% k = k(a,b) = 1/( exp( -a*log(a/b)/(a-b) ) - exp( -b*log(a/b)/(a-b) ) )

v_base = median(wave(tInfo.zero:tInfo.index)); 
[v_peak,t_peak] = max(wave_DC); 

if t_peak > 5000
    [~,t_peak] = max(abs(wave)); 
    v_peak = wave_DC(t_peak);
end

slope_up = median(diff(wave_DC(tInfo.index:t_peak))) * fs; 
if isnan(slope_up), 
    slope_up = median(diff(wave_DC(tInfo.zero:t_peak))) * fs; 
end
slope_dn = median(diff(wave_DC(t_peak:end))) * fs; 

% From the time-to-peak and slope ratio, we can estimate the ratio and
% product of a and b to generate a starting point for the fit

AB_ratio = sqrt(exp(1.20)*(-slope_up/slope_dn) ^exp(1.31)); % dirty estimate 
AB_product = 2 / (time(t_peak) - time(tInfo.index)); 

est_A = abs(sqrt(AB_product / AB_ratio)); 
est_B = abs(sqrt(AB_product * AB_ratio)); 

% Define equations
t = @(p) log(p(1)/p(2)) / (p(1)-p(2)); % peak time = log(a/b) / (a-b)
k = @(p) 1/(exp(-p(1) * t(p) ) - exp(-p(2) * t(p)) ); 

dexp = @(t,p) k(p(1:2))*(exp(-p(1)*t) - exp(-p(2)*t)) .* (t>0); 
DC_model = @(t,p) p(3) * dexp(t-p(5),p) + p(4); 

% fprintf('Rise time ~ %0.2f meas, %0.2f fit_p0\n', ...
%                         time(t_peak) - time(tInfo.index), ...
%                         t_pk([est_A est_B]))

lsq = @(p) mean((wave_DC' - real(DC_model(time,p))).^2); 
fit_IC = [est_A  est_B  v_peak-v_base  v_base  time(tInfo.index)];

if any(isnan(fit_IC))
    fit_IC = [1 5 0 v_base time(tInfo.index)]; 
end

fit_DC = fminsearch(lsq,fit_IC);
fit_DC(5) = max(fit_DC(5),0); 

if do_PLOT
    clf, subplot(3,1,1), cla
    plot(time,wave,'Color',G(7)), hold on, 
    plot(time,DC_model(time,fit_IC),'-','Color',(C(1,:)+1)/2,'LineWidth',0.8)
    plot(time,DC_model(time,fit_DC),'-','Color',C(1,:),'LineWidth',1.5)
    plot(time,wave_DC,'LineWidth',1.2,'Color',G(2))    
    axis tight, tidyPlotForIllustrator, xlim(time([1 end]))
    set(gca,'Xcolor','none'), ylabel('Fit: DC component')
end

clear est_A est_B t_pk AB_ratio AB_product slope_up slope_dn 
clear v_base v_peak t_peak fit_IC lsq

%% ... then fit AC component 

t_scaled = 2*pi*time(roi)*nS; 
oscillation = wave(roi) - DC_model(time(roi),fit_DC)'; 
f1_power = oscillation' / [cos(t_scaled); sin(t_scaled)]; 

est_E = (filtfilt(filters.HP_SOS,filters.HP_G,oscillation));
est_E = max(abs(est_E)) / sqrt(sum(f1_power.^2)); % modulation strength
f1_power = f1_power * est_E; % Boost, then fix "E" to unity in dexp model

AC_model = @(t,p) dexp(t-p(5),abs(p)) .* (p(3) * cos(2*pi*t*nS) + ...
                                     p(4) * sin(2*pi*t*nS)); 
                                 
lsq = @(p) mean((oscillation' - AC_model(time(roi),p)).^2); 
fit_IC = [abs(fit_DC(1:2)) f1_power fit_DC(5)]; 
fit_AC = fminsearch(lsq,fit_IC);
fit_AC(5) = max(fit_AC(5),0); 
fit_AC(1:2) = abs(fit_AC(1:2)); 

if do_PLOT 
    subplot(3,1,2), cla, hold on    
    plot(time(roi),f1_power * [cos(t_scaled); sin(t_scaled)], ...
        'Color',G(2),'LineWidth',1.2)
    plot(time(roi),AC_model(time(roi),fit_IC),'-','Color',(C(2,:)+1)/2,'LineWidth',0.8)
    plot(time(roi), real(oscillation),'color',G(6),'LineWidth',1.1)    
    plot(time(roi),AC_model(time(roi),fit_AC),'-','Color',C(2,:),'LineWidth',1.5)
    axis tight, tidyPlotForIllustrator, xlim(time([1 end]))
    set(gca,'Xcolor','none'), ylabel('Fit: AC component')
end

%% Fit complete wave

full_model = @(t,p) p(5) * real(dexp(t-p(9),abs(p(1:2)))) + p(8) + ...
                           real(dexp(t-p(9),abs(p(3:4)))) .* ...
                                 (p(6) * cos(2*pi*(t-p(9))*p(10)) + ...
                                  p(7) * sin(2*pi*(t-p(9))*p(10)));

fit_opts = optimset('MaxFunEvals',5e3,'MaxIter',5e3); 

lsq = @(p) nanmean((wave' - full_model(time,[p nS])).^2); 
full_IC = [fit_DC(1:2) fit_AC(1:2) ... % [a/b] for DC, AC models
           fit_DC(3) fit_AC(3:4) ...   % E_dc E_cos E_sin
           fit_DC(4) (fit_DC(5) + fit_AC(5))/2]; % E_base, delay 

if any(named('-delay'))    
    dT = varargin{find(named('-delay'))+1};
    lsq = @(p) nanmean((wave' - full_model(time,[p dT nS])).^2); 
    full_IC(end) = [];
else dT = full_IC(9); 
end

rot = [cos(-2*pi*dT*nS) -sin(-2*pi*dT*nS)
       sin(-2*pi*dT*nS)  cos(-2*pi*dT*nS)]; 
full_IC(6:7) = full_IC(6:7) / rot; 

% f1_power = full_IC(6:7); 
%    
% clf % Validate the modification to the periodic RE/IM coefficients
% subplot(2,1,1), hold on   
% plot(time, cos(2*pi*time*nS),'Color',C(1,:))
% plot(time, sin(2*pi*time*nS),'Color',C(3,:))
% 
% plot(time,f1_power * [cos(2*pi*time*nS); sin(2*pi*time*nS)], ...
%         'Color',G(2),'LineWidth',1.2)
% 
% plot([0 0],ylim,'-','Color',[0 0 0 0.3])
% 
% subplot(2,1,2), hold on   
% 
% plot(time, cos(2*pi*(time-dT)*nS),'Color',C(1,:))
% plot(time, sin(2*pi*(time-dT)*nS),'Color',C(3,:))
% plot(time,f1_power * [cos(2*pi*time*nS); sin(2*pi*time*nS)], ...
%         'Color',G(8),'LineWidth',1.2)
% plot(time,f1_power / rot * [cos(2*pi*(time-dT)*nS); ...
%                             sin(2*pi*(time-dT)*nS)], ...
%         '--','Color',G(2),'LineWidth',1.2)
%     
% plot([dT dT],ylim,'-','Color',[0 0 0 0.3])

%%


% x = fmincon(fun,x0,[],[],[],[],LB,UB,[],fit_opts)

full_PAR = fminsearch(lsq,full_IC,fit_opts); 
if any(named('-delay')), full_PAR = [full_PAR dT]; end

full_PAR = [full_PAR nS]; 
full_PAR(1:4) = abs(full_PAR(1:4)); 
if full_PAR(1) > full_PAR(2), full_PAR([2 1]) = full_PAR(1:2); end
if full_PAR(3) > full_PAR(4), full_PAR([4 3]) = full_PAR(3:4); end

if do_PLOT 
    subplot(3,1,3), cla, hold on    
    plot(time, full_model(time,full_PAR .* [1 1 1 1 1 0 0 1 1 1]), ...
                                         'LineWidth',1.0,'Color',C(1,:));    
    plot(time, full_model(time,full_PAR),'LineWidth',1.5,'Color',C(2,:));
    plot(time, wave, '-','Color',G(2))
    axis tight, tidyPlotForIllustrator, xlim(time([1 end]))
    ylabel('Fit: Full model')
end


rmse = sqrt(nanmean((full_model(time,full_PAR) - wave').^2));

%% Format for output

% full_PAR = fminsearch(lsq,full_PAR(1:9)); 

response.name  = 'Double-Exponential wave';
response.units = {'\alpha_{DC}','\beta_{DC}', ...
                  '\alpha_{AC}','\beta_{AC}', ...
                  'gain_{DC}','gain_{AC} (cos)', 'gain_{AC} (sin)', ...
                  'baseline','delay (s)','stimulus TF (Hz)'}; 

response.equation = func2str(full_model); 
response.eq.t = func2str(t); % Expression for time of maximum
response.eq.k = func2str(k); % Normalisation factor for dexp
response.eq.dexp = func2str(dexp); % double-exponential kernal
response.params = full_PAR;
response.rmse = rmse; 

return
