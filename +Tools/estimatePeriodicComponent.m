
function est = estimatePeriodicComponent(wave, varargin)
% estimate = estimatePeriodicComponent( wave, [time], [expoData], <args> )
%                                     ( wave, time, tInfo, <args> )
% Generate an approximate impulse response based on the input wave. 
% 
% tInfo may be generated by 
%    tInfo = Tools.estimateWaveLag(wave,time,expoData);


named = @(n) strncmpi(varargin,n,length(n));
do_PLOT = any(named('-plot')); 
do_INFO = true; 

if nargin == 0 || nargin > 1e3, do_PLOT = true; 
    
    disp('Running demonstration (PCA 1):')
    Tools.loadPhysiology('8.6.1 #18','-pca','-nK',6);
    wave = score(:,1); %#ok<NODEF>
    
    tInfo = Tools.estimateWaveLag(wave,'-plot'); 
    
    % Remove variables that non-test-case use doesn't have access to
    clear coeff coe_scale filename hekaData nPasses 
    clear passes resting score stim_bar

elseif nargin < 3
     expoData = evalin('caller','expoData'); % Needed to compute tInfo
     time = evalin('caller','time');
     tInfo = Tools.estimateWaveLag(wave,time,expoData);
else 
     tInfo = varargin{2};
     time = varargin{1};
     if isfield(tInfo,'ExpoVersion'), % passed in as (wave,time,expoData)
          tInfo = Tools.estimateWaveLag(wave,time,tInfo);
     else do_INFO = false; 
     end
end

nStimuli = tInfo.nStimuli; 
if tInfo.nStimuli == 1,
    warning('CDE:estimatePeriodicComponent','I don''t reccomend computing the periodic component response to a single stimulus per pass')
end

if ~any(named('-nP')), nP = 4;
else nP = varargin{find(named('-nP'))+1};
end

idx = (0:nP-1)*tInfo.duration + tInfo.index;
nP = sum(idx < numel(wave));


do_WRAP = ~any(named('-trim')); % process slightly differently

%%
response = zeros(tInfo.duration,nP); % Periodic component
% residual = zeros(tInfo.duration,nP); % Aperiodic component

if do_PLOT, wave_RAW = wave; end

signal_floor = median(wave(tInfo.zero:tInfo.index));
wave = wave - signal_floor; 

if do_WRAP
    % We want to modify "wave" slightly so that it wraps around
    t0 = ceil( tInfo.zero / 2 );
    wave(1:t0) = wave(1:t0) .* linspace(0,1,t0)' + ...
                 wave(end:-1:end-t0+1) .* linspace(1,0,t0)';
end

nT = length(time); 

f_opts = optimset('Display','off','MaxIter',2e3,'MaxFunEvals',2e3); 
% lambda = 100; 
printInfo; 

for tt = 1:tInfo.duration
    
    printInfo('Calculating periodic component... %0.1f%% ', 100*tt/tInfo.duration)
    
    idx = (0:nP-1)*tInfo.duration + tInfo.index + (tt-1);
    
    if do_WRAP, idx = mod(idx-1,nT)+1; % Wrap the ends around?         
    else        idx(idx > nT) = []; % Trim the ends off
    end
    
    nI = length(idx);
    val = reshape(wave(idx),1,[]);
    
    % PERIODIC part R is best solution to equations
    %   r1 = v1, r2 = v2, r1+r3 = v3, r2+r4 = v4, ...
    % subject to constraint r1+r2+r3+... = 0.      
    % build this out as a system of equations:
    
    A = zeros(nP);
    for ii = 0:(nP/2)
        % A((2*nP*ii+1):(nP+1):(nP*nI)) = 1;          
        A = A + diag(ones(1,nP-2*ii),2*ii);
    end    
    A = A(:,1:nI); 
    
    % Initialise with a little linear algebra
    r0 =  [val 0] / [A 1+0*A(:,1)];
    
    if tt > 1, 
        % if abs(sum(r0)) close to 0, r0 has a lot of influence on initial
        % guess.
        wt = abs(sum(r0)) / 5; 
        r0 = (response(tt-1,:)*(wt+0.2) + r0 - sum(r0)) / (wt + 1.2);
    end
    
    % lsq = @(r) mean( ([r(1:nP-1) -sum(r(1:nP-1))]*A ...
    %                  + r(nP:end) - val).^2 + lambda*r(nP:end).^2);
    % r1 = fminsearch(lsq, [r0(1:end-1) zeros(1,nI)], f_opts);
    
    lsq = @(r) mean( ([r -sum(r)]*A - val).^2 );
    r1 = fminsearch(lsq, r0(1:end-1), f_opts);    
    
    response(tt,:) = [r1 -sum(r1)];
    % residual(tt,1:nI) = r1(nP:end);
end

clear tt r1 r0 t0 lsq idx nI val A wt

% DEBUG_response = response; 
% r_time = (1:numel(response)) * mean(diff(time));
% clf, plot(r_time,response(:))

%% Make the trace continuous. 

fprintf('\nApplying continuity constraint ... \n')

nR = size(response,1); 
vals = response([1 end],:);
vtgt = (vals(1,:) + vals(2,[end 1:end-1])) / 2;
v01 = linspace(0,1,nR)'; 

for pp = 1:nP
    id = mod(pp-[1 0],nP) + 1;    
    response(:,pp) = response(:,pp) - vals(1,pp)*(1-v01) - vals(2,pp)*v01 ...
                                    + vtgt(id(1))*(1-v01) + vtgt(id(2))*v01; 
end

% Make the start and end begin from zero (cubic)
z = response(1); 
response(:,1) = response(:,1) - (z*(1-v01).^3); 
response(:,end) = response(:,end) + (z*(1-v01).^3) - (z*v01.^3); 
response(:,end-1) = response(:,end-1) + (z*v01.^3); 

% Correct for jump when the fit hits the end of the wave
for ss = 1:nStimuli % check each stimulus 
    idx = tInfo.index + (2*ss-2)*tInfo.duration;         
    if idx + numel(response) < nT, continue, end
    
    idx = find(idx + (1:numel(response)) > nT, 1);
    [tt,pp] = ind2sub(size(response),idx);
    jdx = idx - nR + [0 1];
    
    if pp == 1, continue, end
    
    z = diff(response(jdx));    
    z = z/2*[linspace(0,1,tt).^2, -linspace(1,0,nR-tt).^2]'; 
    
%     clf, hold on    
%     plot(r_time,response(:))    
%     plot(r_time(jdx), response(jdx),'ro') 
%     plot(r_time(1:size(response,1):end), response(1,:),'rs') 

    % Apply calculated correction
    response(:,pp) = response(:,pp) - z;
    response(:,pp-1) = response(:,pp-1) + z;
    
%     plot(r_time,response(:))
%     ginput(1)
end

% Fix rounding errors
response(:,end) = response(:,end) - sum(response,2);

clear idx jdx ss tt pp z vals vtgt id 

%% Refine by incorporating a constant offset term (helps) 
% Having applied constraints

fprintf('Incorporating offset term ... \n')

idx = (0:nP-1)*tInfo.duration + tInfo.index;

A = zeros(nP);
for ii = 0:(nP/2)
    A = A + diag(ones(1,nP-2*ii),2*ii);
end

dY = wave(idx)' - response(1,:) * A; 
dY(1) = 0; % initial estimate of +c

% Change to consider constant sum
A(1,:) = 1; A(:,1) = 1; A(1,1) = 0;
dR = (dY / A); 

signal_const = dR(1); dR(1) = []; 
dR = dR - sum(dR)/numel(dR); 

dR = [0 dR 0]; 
for pp = 1:nP
    response(:,pp) = response(:,pp) + dR(pp) * (1-v01) + dR(pp+1) * v01;
end

clear A dY dR ii pp idx 

%% Compute response to multiple stimuli

stim_trace = 0*time; 
est_trace = 0*time; 

% clf, hold on, plot(time,wave,'k-')
% h = plot(time,est_trace,'Color',C(2,:)); 

for ss = 1:nStimuli
    
    idx = tInfo.index + (2*ss-2)*tInfo.duration;
    stim_trace(idx) = 1;
    
    % set(gca,'Children',flipud(get(gca,'Children')));
    % plot(r_time + time(idx), response(:),'Color',[C(1,:) .5])
    % set(gca,'Children',flipud(get(gca,'Children')));
    
    idx = idx + (1:numel(response));
    ok = (idx <= numel(time));
    est_trace(idx(ok)) = est_trace(idx(ok)) + response(ok);
    
%     idx = mod(idx-1,nT)+1; % Wrap around   
%     est_trace(idx) = est_trace(idx) + response(:)';

    % h.YData = est_trace; 
end

%% Plot response and residual

t = (1:numel(response)) * mean(diff(time)) + time(tInfo.index);

if do_PLOT
    
    figure('Color','w'), clf, hold on
    C = lines(7);

    plot(time, wave_RAW, 'k-')
    plot(time,est_trace + signal_const + signal_floor)
    plot(time,wave - est_trace' + signal_floor, 'Color', [C(2,:) 0.3])
    plot(t,response(:),'-','Color',C(3,:),'Clipping','off')

    tidyPlotForIllustrator, xlim(time([1 end]))
        
    stim_bar = @(i,h) [(i-1)/nStimuli ylim*[h;1-h] 1/nStimuli/2 ylim*[-1;1]*abs(h/3)];

    for ss = 1:nStimuli,
        rectangle('Position',stim_bar(ss,0.1),'FaceColor',[0 0 0 0.5], 'EdgeColor','none')
    end
end

%% Format output

est.periodic = response(:)';
est.response = est_trace + signal_const + signal_floor; 
est.latency = time(tInfo.index); 
est.time = t; 

est.input = stim_trace; 
est.aperiodic = signal_const;
est.signal_floor = signal_floor;
est.n_phases = nP;

if do_INFO, est.timing = tInfo; end

